import numpy as np
import copy
import math
from math import sqrt
from PyQt5 import QtGui, QtCore, QtWidgets
from PyQt5.Qt import QTransform
from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, QLabel, QVBoxLayout, QWidget


class Board(QtWidgets.QFrame):
    SPEED = 100

    WIDTHINBLOCKS = 8
    HEIGHTINBLOCKS = 7
    max_possible_level = 7  # max possible level of enemies

    def __init__(self, parent):
        super(Board, self).__init__(parent)

        self.coins = QtGui.QImage("Sprites/coins.png")
        self.menu = QtGui.QImage("Sprites/menu.png")
        self.heart = QtGui.QImage("Sprites/heart.png")
        self.wave_menu = QtGui.QImage("Sprites/wave_level.png")
        self.alien = QtGui.QImage("Sprites/alien.png")

        self.combo = BuyMenu()

        self.tower_places = [[6, 1], [7, 3], [17, 1], [13, 4], [11, 7]]

        self.enemies = []
        self.enemies_in_reserve = []  # levels of enemies which were generated by wave
                                      # and now are waiting for their turn to appear
        self.wizards = []
        self.archers = [Archer([6, 1], 3), Archer([7, 3], 3), Archer([17, 1], 3), Archer([13, 4], 3), Archer([11, 7], 3)]
        self.wizardsAttacks = []   # for fireballs trajectories
        self.archersAttacks = []   # for bows trajectories

        self.wizardsAttacks = []
        self.archersAttacks = []

        self.land_tiles = []
        self.roads = []
        self.decor = []
        self.biome = "spring"

        self.fire_counter = 0  # counter of delay for towers fire
        self.spawn_counter = 0  # counter of delay for units spawn during a wave
        self.wave_counter = 0  # counter for pause between waves
        self.move_counter = 0

        self.fire_delay = 3  # count of iteration between towers' fire
        self.spawn_delay = 4  # count of iteration between spawns in a wave
        self.first_wave_delay = 40  # count of iteration before 2 wave
        self.wave_delay = self.first_wave_delay  # count of iteration before between waves
        self.wave_menu_delay = 30  # count of iteration before hide wave_menu
        self.start_delay = 50  # delay before starting of waves

        self.setFocusPolicy(QtCore.Qt.FocusPolicy.StrongFocus)

        self.castleHP = 1000
        self.castlePosition = [14, 8]
        self.money_count = 1000

        self.spawn_point = self.road_generation()[0]
        self.wave_level = 0
        self.units_in_first_wave = 4

        self.timer = QtCore.QBasicTimer()

        self.board_generation()

    # UNITS AND TOWERS LOGIC
    def enemy_wave(self, wave_level):   # create enemies in accordance with wave_level
        self.wave_level += 1
        # self.wave_delay += self.first_wave_delay
        units_count = self.units_in_first_wave * self.wave_level  # units in wave: 4, 8, 12, 16...
        low_units_level = wave_level % self.max_possible_level
        enemy_levels = np.random.randint(low_units_level,
                                         high=min(wave_level + 1, self.max_possible_level), size=units_count)
        for i in range(units_count):
            unit_level = enemy_levels[i]
            self.enemies_in_reserve.append(unit_level)

    def add_enemy_to_fight(self):
        self.enemies.append(UFO(copy.deepcopy(self.spawn_point), self.enemies_in_reserve.pop(0)))

    @staticmethod
    def in_range(target, tower) -> bool:  # return true if a particular unit in the tower's range
        dx = tower.position[0] - target.position[0]
        dy = tower.position[1] - target.position[1]
        distance = sqrt(dx ** 2 + dy ** 2)
        if distance <= tower.range:
            return True
        else:
            return False

    def shelling(self):
        for a in range(len(self.archers)):
            for e in range(len(self.enemies)):
                archer = self.archers[a]
                enemy = self.enemies[e]
                if self.in_range(enemy, archer):
                    self.enemies[e].take_damage(self.archers[a].make_damage())
                    self.archersAttacks.append((enemy.position, archer.position))
                    break

        for w in range(len(self.wizards)):
            for e in range(len(self.enemies)):
                wizard = self.wizards[w]
                enemy = self.enemies[e]
                if self.in_range(enemy, wizard):
                    self.wizardsAttacks.append((enemy.position, wizard.position))
                    self.enemies[e].take_damage(self.wizards[w].make_damage())

    def units_move(self):
        for i in range(len(self.enemies)):
            if self.move_counter % self.enemies[i].velocity == 0:
                self.enemies[i].move(self.trajectory(self.enemies[i].position))

    def units_destroy(self):
        for enemy in self.enemies:
            if enemy.position == self.castlePosition:
                self.enemies.remove(enemy)

    def castle_damage(self):
        for enemy in self.enemies:
            if enemy.position == self.castlePosition:
                self.castleHP -= enemy.force

    # MONEY
    def get_money(self):
        for enemy in self.enemies:
            if not (enemy.is_alive()):
                self.money_count += enemy.money_award
                self.enemies.remove(enemy)

    # TIMER AND MOUSE
    def start(self):
        self.timer.start(Board.SPEED, self)

    def timerEvent(self, a0: QtCore.QTimerEvent) -> None:
        if a0.timerId() == self.timer.timerId():
            if self.start_delay != 0:
                self.start_delay -= 1
                return

            self.units_move()
            self.castle_damage()
            self.units_destroy()

            if self.fire_counter % self.fire_delay == 0:
                self.shelling()

            if self.fire_counter % self.fire_delay == 1:
                self.get_money()

            if self.fire_counter % self.fire_delay == 1:
                self.archersAttacks.clear()
                self.wizardsAttacks.clear()

            if self.wave_counter % self.wave_delay == 0:
                self.enemy_wave(self.wave_level)

            if len(self.enemies_in_reserve) != 0 and self.spawn_counter % self.spawn_delay == 0:
                self.add_enemy_to_fight()

            self.fire_counter = self.fire_counter % self.fire_delay + 1
            self.wave_counter = self.wave_counter % self.wave_delay + 1
            self.spawn_counter = self.spawn_counter % self.spawn_delay + 1
            self.move_counter = self.move_counter % (self.max_possible_level + 1) + 1
            self.update()

    def mousePressEvent(self, a0: QtGui.QMouseEvent) -> None:
        for coord in self.tower_places:
            if self.x_coord(coord[1], coord[0]) <= a0.x() <= self.x_coord(coord[1], coord[0]) + self.tile_width() \
                    and self.y_coord(coord[0]) <= a0.y() <= self.y_coord(coord[0]) + self.tile_height():
                self.combo.show()

    # MAP GENERATION
    def trajectory(self, coord):
        road = self.road_generation()
        if coord in road[:-1]:
            coord = road[road.index(coord) + 1]
        else:
            coord[0] += 1
            coord[1] += 1
        return coord

    @staticmethod
    def road_generation():
        road = [[i, i // 2 - 1] for i in range(2, 10)]
        road += [[i, 3 - i % 2 - (i - 10) // 2] for i in range(10, 15)]
        road += [[i, i // 2 - 6] for i in range(15, 19)]
        road += [[i, 3 + (17 - i) % 2 + (17 - i) // 2] for i in range(17, 10, -1)]
        road += [[i, i // 2 + 1] for i in range(12, 15)]
        return road

    def board_generation(self):
        road_traj = self.road_generation()
        tower_places = [[6, 1], [7, 3], [17, 1], [13, 4], [11, 7]]
        environments = [[5, 5], [14, 6], [10, 1], [1, 2], [18, 4], [19, 1], [2, 7]]
        for i in range(0, 3 * self.HEIGHTINBLOCKS + 3, 1):
            for j in range(0, self.WIDTHINBLOCKS + 1, 1):
                if [i, j] in tower_places:
                    self.land_tiles.append(Landscape(np.array([i, j]), self.biome, tower_place=True))
                elif [i, j] in road_traj:
                    if [i, j] == [9, 3]:
                        self.land_tiles.append(Road(np.array([i, j]), self.biome, "left_twist"))
                    elif [i, j] == [14, 1]:
                        self.land_tiles.append(Road(np.array([i, j]), self.biome, "right_twist"))
                    elif [i, j] == [18, 3]:
                        self.land_tiles.append(Road(np.array([i, j]), self.biome, "top_twist"))
                    elif [i, j] == [11, 6]:
                        self.land_tiles.append(Road(np.array([i, j]), self.biome, "bottom_twist"))
                    else:
                        if road_traj.index([9, 3]) < road_traj.index([i, j]) < road_traj.index([14, 1]):
                            self.land_tiles.append(Road(np.array([i, j]), self.biome, "left"))
                        elif road_traj.index([18, 3]) < road_traj.index([i, j]) < road_traj.index([11, 6]):
                            self.land_tiles.append(Road(np.array([i, j]), self.biome, "left"))
                        else:
                            self.land_tiles.append(Road(np.array([i, j]), self.biome, "right"))
                else:
                    self.land_tiles.append(Landscape(np.array([i, j]), self.biome, tower_place=False))
                if [i, j] in environments:
                    if [i, j] in environments[:3]:
                        self.decor.append(EnvironmentalTiles(np.array([i, j]), self.biome, "plant2"))
                    elif [i, j] in environments[3:6]:
                        self.decor.append(EnvironmentalTiles(np.array([i, j]), self.biome, "plant1"))
                    else:
                        self.decor.append(EnvironmentalTiles(np.array([i, j]), self.biome, "decoration1"))

    def tile_width(self):
        return self.frameGeometry().width() / self.WIDTHINBLOCKS

    def tile_height(self):
        return self.frameGeometry().height() / self.HEIGHTINBLOCKS

    def y_coord(self, y_line):
        height = self.tile_height()
        if y_line == 0:
            return -height / 2 - self.tile_height() / 5.5 * y_line
        else:
            return height / 2 * (y_line - 1) - self.tile_height() / 5.5 * y_line

    def x_coord(self, x_line, y_line):
        width = self.tile_width()
        if y_line % 2 == 0:
            return -width / 2 + width * x_line
        else:
            return width * x_line

    # PAINTING OF MAP
    def draw_rect(self, painter, x, y, image, width=None, height=None):
        if width is None:
            width = self.tile_width()
        if height is None:
            height = self.tile_height()
        rect = QtCore.QRect(int(x), int(y), int(width), int(height))
        painter.drawImage(rect, image)

    def paintEvent(self, a0: QtGui.QPaintEvent) -> None:
        painter = QtGui.QPainter(self)
        rect = self.contentsRect()
        board_top = rect.bottom() - self.frameGeometry().height()

        self.paint_land(painter, rect, board_top)
        self.paint_decoration(painter, rect, board_top)

        self.paint_towers(painter, rect, board_top)
        if self.fire_counter % self.fire_delay == 1:  # if it's fire iteration
            self.paint_shoots(painter)
        self.paint_units(painter, rect, board_top)

        if self.wave_menu_delay >= self.wave_counter % self.wave_delay > 0 == self.start_delay:
            self.draw_wave_menu(painter)
        self.draw_menu(painter)

    def paint_land(self, painter, rect, board_top):
        for land in self.land_tiles:
            i = land.position[0]
            j = land.position[1]
            y = self.y_coord(i)
            x = self.x_coord(j, i)
            self.draw_rect(painter, rect.left() + x, board_top + y, land.skin)

    def paint_decoration(self, painter, rect, board_top):
        for decoration in self.decor:
            i = decoration.position[0]
            j = decoration.position[1]
            y = self.y_coord(i)
            x = self.x_coord(j, i)
            self.draw_rect(painter, rect.left() + x + self.tile_width() / 5.5, board_top + y + self.tile_height() / 2.5,
                           decoration.skin, self.tile_width() / 1.5, self.tile_height() / 1.5)

    def paint_towers(self, painter, rect, board_top):
        for archer in self.archers:
            coord = archer.position
            i = coord[0]
            j = coord[1]
            y = self.y_coord(i)
            x = self.x_coord(j, i)
            x_shift = self.tile_width() / 9
            y_shift = self.tile_height() / 5
            width_compression = 1.3
            height_compression = 1.3
            self.draw_rect(painter, rect.left() + x + x_shift, board_top + y - y_shift, archer.skin,
                           width=self.tile_width() / width_compression,
                           height=self.tile_height() / height_compression)

        for wizard in self.wizards:
            coord = wizard.position
            i = coord[0]
            j = coord[1]
            y = self.y_coord(i)
            x = self.x_coord(j, i)
            self.draw_rect(painter, rect.left() + x, board_top + y, wizard.skin)

    def paint_shoots(self, painter):
        for enemy, archer in self.archersAttacks:
            x1 = self.x_coord(archer[1], archer[0]) + self.tile_width() / 2
            y1 = self.y_coord(archer[0]) + self.tile_height() / 4
            x2 = self.x_coord(enemy[1], enemy[0]) + self.tile_width() / 2
            y2 = self.y_coord(enemy[0]) + self.tile_height() / 4
            painter.drawLine(int(x1), int(y1), int(x2), int(y2))
        for enemy, wizard in self.wizardsAttacks:
            x1 = self.x_coord(wizard[1], wizard[0])
            y1 = self.y_coord(wizard[0])
            x2 = self.x_coord(enemy[1], enemy[0])
            y2 = self.y_coord(enemy[0])
            painter.drawLine(int(x1), int(y1), int(x2), int(y2))

    def paint_units(self, painter, rect, board_top):
        for enemy in self.enemies:
            coord = enemy.position
            i = coord[0]
            j = coord[1]
            y = self.y_coord(i)
            x = self.x_coord(j, i)
            x_shift = self.tile_width() / 4 + 10
            y_shift = 10
            width_compression = 3
            height_compression = 3
            self.draw_rect(painter, rect.left() + x + x_shift, board_top + y + y_shift, enemy.skin,
                           width=self.tile_width() / width_compression,
                           height=self.tile_height() / height_compression)

    def draw_wave_menu(self, painter):
        x_wave = self.frameGeometry().width() / 100 * 65  # x coord of wave block
        y_wave = self.frameGeometry().height() / 100 * 78  # y coord of wave block
        self.draw_rect(painter, x_wave, y_wave, self.wave_menu,
                       width=self.tile_width() * 2.5, height=self.tile_height() * 1.4)
        self.draw_rect(painter, x_wave * 1.09, y_wave * 1.09, self.alien,
                       width=self.tile_width() / 3, height=self.tile_height() / 2)

        font = painter.font()
        font.setPixelSize(50)
        painter.setFont(font)

        painter.drawText(int(x_wave * 1.18), int(y_wave * 1.09), 300, 200, 0, "WAVE " + str(self.wave_level))

    def draw_menu(self, painter):
        x_menu = self.frameGeometry().width() / 100 * 65  # x coord of menu block
        y_menu = self.frameGeometry().height() / 100  # y coord of menu block

        self.draw_rect(painter, x_menu, y_menu, self.menu,
                       width=self.tile_width() * 2.5, height=self.tile_height() * 1.4)
        self.draw_rect(painter, x_menu * 1.32, y_menu * 8.2, self.heart,
                       width=self.tile_width() / 3, height=self.tile_height() / 3)

        self.draw_rect(painter, x_menu * 1.16, y_menu * 8, self.coins,
                       width=self.tile_width() / 4, height=self.tile_height() / 3)
        self.draw_rect(painter, x_menu * 1.32, y_menu * 8.2, self.heart,
                       width=self.tile_width() / 3, height=self.tile_height() / 3)

        font = painter.font()
        font.setPixelSize(25)
        painter.setFont(font)

        painter.drawText(int(x_menu * 1.08), int(y_menu * 9), 100, 200, 0, str(self.money_count))
        painter.drawText(int(x_menu * 1.24), int(y_menu * 9), 100, 200, 0, str(self.castleHP))


class Unit:
    def __init__(self, coord, level, skins, direction):
        self.position = coord
        self.level = level
        self.HP = 30 * level
        self.skin = skins[level - 1]
        max_possible_level = 7
        self.velocity = max_possible_level - level + 1  # 1 square in 7, 6, 5, 4, 3, 2, 1 iteration
        self.force = 10 * level  # 10, 20, 30... damage (for units and castle)

    def move(self, coord):
        self.position = coord

    def take_damage(self, value):
        self.HP -= value
        if self.HP <= 0:
            self.HP = 0

    def is_alive(self) -> bool:
        if self.HP == 0:
            return False
        else:
            return True

    def make_damage(self) -> int:
        return self.force


class Warrior(Unit):
    def __init__(self, coord, level):
        skins = [QtGui.QImage("Sprites/Towers/Barrack/warrior_level_1.png"),
                 QtGui.QImage("Sprites/Towers/Barrack/warrior_level_2.png"),
                 QtGui.QImage("Sprites/Towers/Barrack/warrior_level_3.png")]
        super().__init__(coord, level, skins, "inverse")


class UFO(Unit):
    def __init__(self, coord, level):
        skins = [QtGui.QImage("Sprites/UFO/UFO(1).png"),
                 QtGui.QImage("Sprites/UFO/UFO(2).png"),
                 QtGui.QImage("Sprites/UFO/UFO(3).png"),
                 QtGui.QImage("Sprites/UFO/UFO(4).png"),
                 QtGui.QImage("Sprites/UFO/UFO(5).png"),
                 QtGui.QImage("Sprites/UFO/UFO(6).png"),
                 QtGui.QImage("Sprites/UFO/UFO(7).png")]
        self.money_award = 20 * level
        super().__init__(coord, level, skins, "direct")


class Tower:
    def __init__(self, coord, level, skins):    # skins is array of QImage
        self.position = coord
        self.level = level
        self.skins = skins
        self.skin = skins[level - 1]
        self.range = 4 * level  # 10, 20, 30 squares
        self.force = 20 * level  # 20, 40, 60 damage
        self.upgrade_cost = level * 50  # 50, 100, 150 coins
        self.building_cost = level * 100  # 100, 200, 300 coins

    def change_picture(self):  # change picture in order to level
        self.skin = self.skins[self.level]

    def level_up(self):
        self.level += 1
        self.range = 10 * self.level  # 10, 20, 30 pixels
        self.force = 10 * self.level  # 20, 40, 60 damage
        self.upgrade_cost = self.level * 50  # 50, 100, 150 coins
        self.change_picture()

    def make_damage(self) -> int:
        return self.force

    def upgrade_cost(self) -> int:  # return upgrade cost
        return self.upgrade_cost


class Archer(Tower):
    def __init__(self, coord, level):
        skins = [QtGui.QImage("Sprites/Towers/Archer/archer_level_1.png"),
                 QtGui.QImage("Sprites/Towers/Archer/archer_level_2.png"),
                 QtGui.QImage("Sprites/Towers/Archer/archer_level_3.png")]

        self.arrow = QtGui.QImage("Sprites/Towers/Archer/arrow.png")

        super().__init__(coord, level, skins)


class Wizard(Tower):
    def __init__(self, coord, level):
        skins = [QtGui.QImage("Sprites/Towers/Barrack/wizard_level_1.png"),
                 QtGui.QImage("Sprites/Towers/Barrack/wizard_level_2.png"),
                 QtGui.QImage("Sprites/Towers/Barrack/wizard_level_3.png")]
        super().__init__(coord, level, skins)


class Tile:
    def __init__(self, coord, skin):
        self.position = coord
        self.skin = skin


class Road(Tile):
    def __init__(self, coord, biome, tile_type):    # np.array(x, y) coord, str biome : {"spring", "winter", "desert"},
                                                    # str tile_type : {"left", "right", "right_top_crossroad",
                                                    # "right_bottom_crossroad", "left_top_crossroad",
                                                    # "left_bottom_crossroad",  "bottom_twist", "top_twist",
                                                    # "right_twist", "left_twist"}
        biome = biome.title()
        skin = QtGui.QImage("Sprites/Road tiles/" + biome + "/" + tile_type + ".png")

        super().__init__(coord, skin)
        self.type = tile_type   # maybe will be needed


class Landscape(Tile):
    def __init__(self, coord, biome, tower_place=False):  # np.array(x, y) coord,
                                                          # str biome = {"spring", "winter", "desert"}, bool tower_place
        desert_biome = [QtGui.QImage("Sprites/Landscape tiles/sand.png"),
                        QtGui.QImage("Sprites/Landscape tiles/buildingPlaceSand.png")]
        spring_biome = [QtGui.QImage("Sprites/Landscape tiles/grass.png"),
                        QtGui.QImage("Sprites/Landscape tiles/buildingPlaceGrass.png")]
        winter_biome = [QtGui.QImage("Sprites/Landscape tiles/snow.png"),
                        QtGui.QImage("Sprites/Landscape tiles/buildingPlaceSnow.png")]

        skin = QtGui.QImage()

        if biome == "desert":
            if tower_place:
                skin = desert_biome[1]
            else:
                skin = desert_biome[0]
        elif biome == "spring":
            if tower_place:
                skin = spring_biome[1]
            else:
                skin = spring_biome[0]
        elif biome == "winter":
            if tower_place:
                skin = winter_biome[1]
            else:
                skin = winter_biome[0]

        super().__init__(coord, skin)
        self.tower_place = tower_place


class EnvironmentalTiles(Tile):
    def __init__(self, coord, biome, tile_type):  # np.array(x, y) coord, str biome = {"spring", "winter", "desert"},

        winter_biome = [QtGui.QImage("Sprites/Enviroument tiles/winter/circle_tree.png"),
                        QtGui.QImage("Sprites/Enviroument tiles/winter/normal_tree.png"),
                        QtGui.QImage("Sprites/Enviroument tiles/winter/snowdrift1.png"),
                        QtGui.QImage("Sprites/Enviroument tiles/winter/snowdrift2.png")]

        spring_biome = [QtGui.QImage("Sprites/Enviroument tiles/spring/circle_tree.png"),
                        QtGui.QImage("Sprites/Enviroument tiles/spring/normal_tree.png"),
                        QtGui.QImage("Sprites/Enviroument tiles/spring/gray_stone.png"),
                        QtGui.QImage("Sprites/Enviroument tiles/spring/gray_big_stone.png")]

        desert_biome = [QtGui.QImage("Sprites/Enviroument tiles/desert/cactus1.png"),
                        QtGui.QImage("Sprites/Enviroument tiles/desert/cactus2.png"),
                        QtGui.QImage("Sprites/Enviroument tiles/desert/sandstone.png"),
                        QtGui.QImage("Sprites/Enviroument tiles/desert/big_sandstone.png")]

        skin = QtGui.QImage()

        if biome == "desert":
            if tile_type == "plant1":
                skin = desert_biome[0]
            elif tile_type == "plant2":
                skin = desert_biome[1]
            elif tile_type == "decoration1":
                skin = desert_biome[2]
            else:
                skin = desert_biome[3]

        elif biome == "spring":
            if tile_type == "plant1":
                skin = spring_biome[0]
            elif tile_type == "plant":
                skin = spring_biome[1]
            elif tile_type == "decoration1":
                skin = spring_biome[2]
            else:
                skin = spring_biome[3]

        elif biome == "winter":
            if tile_type == "plant1":
                skin = winter_biome[0]
            elif tile_type == "plant2":
                skin = winter_biome[1]
            elif tile_type == "decoration1":
                skin = winter_biome[2]
            else:
                skin = winter_biome[3]

        super().__init__(coord, skin)


class BuyMenu(QLabel):
    def __init__(self):
        super().__init__()

        self.setWindowTitle("Buy menu")
        self.setFixedSize(250, 200)
        self.archer_cost = 150
        self.wizard_cost = 200
        self.archer_buy = False
        self.wizard_buy = False

    def paintEvent(self, a0: QtGui.QPaintEvent) -> None:
        painter = QtGui.QPainter(self)
        archer_rect = QtCore.QRect(int(10), int(10), int(100), int(100))
        wizard_rect = QtCore.QRect(int(150), int(10), int(100), int(100))

        painter.drawImage(archer_rect, QtGui.QImage("Sprites/Towers/Archer/archer_level_1.png"))
        painter.drawImage(wizard_rect, QtGui.QImage("Sprites/Towers/Wizard/wizard_level_1.png"))

        font = painter.font()
        font.setPixelSize(25)
        painter.setFont(font)

        painter.drawText(35, 130, 100, 100, 0, str(self.archer_cost))
        painter.drawText(175, 130, 100, 200, 0, str(self.wizard_cost))

    def mousePressEvent(self, a0: QtGui.QMouseEvent) -> None:
        if 10 <= a0.x() <= 110 and 10 <= a0.y() <= 110:
            self.archer_buy = True
        elif 150 <= a0.x() <= 250 and 10 <= a0.y() <= 110:
            self.wizard_buy = True


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()

        self.board = Board(self)
        self.setCentralWidget(self.board)
        self.setGeometry(100, 50, 1500, 950)
        self.setWindowTitle("Ultra tower defence")
        self.board.start()
        self.show()


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = MainWindow()
    MainWindow.show()
    sys.exit(app.exec_())
