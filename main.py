import numpy as np
import copy
from math import sqrt
from PyQt5 import QtGui, QtCore, QtWidgets


class Board(QtWidgets.QFrame):
    SPEED = 500

    WIDTHINBLOCKS = 8
    HEIGHTINBLOCKS = 7
    max_possible_level = 7  # max possible level of enemies

    def __init__(self, parent):
        super(Board, self).__init__(parent)

        self.enemies = [UFO(np.array([7, 5]), 5)]
        self.enemies_in_reserve = []  # levels of enemies which were generated by wave
                                      # and now are waiting for their turn to appear
        self.wizards = []
        self.archers = [Archer(np.array([4, 6]), 1)]
        self.wizardsAttacks = []   # for fireballs trajectories
        self.archersAttacks = []   # for bows trajectories

        self.wizardsAttacks = []
        self.archersAttacks = []

        self.land_tiles = []
        self.roads = []
        self.decor = []
        self.biome = "spring"

        self.fire_delay = 0  # counter of delay for towers fire
        self.spawn_delay = 0  # counter of delay for units spawn during a wave
        self.wave_delay = 0  # counter for pause between waves

        self.setFocusPolicy(QtCore.Qt.FocusPolicy.StrongFocus)

        self.castleHP = 1000
        self.castlePosition = np.array([100, 100], dtype=int)

        self.spawn_point = np.array([4, 5])
        self.wave_level = 1

        self.timer = QtCore.QBasicTimer()

        self.board_generation()

    def enemy_wave(self, wave_level):   # create enemies in accordance with wave_level
        units_count = 1 * wave_level  # units in wave: 4, 8, 12, 16...
        low_units_level = wave_level % self.max_possible_level
        enemy_levels = np.random.randint(low_units_level, high=wave_level + 1, size=units_count)
        for i in range(units_count):
            unit_level = enemy_levels[i]
            self.enemies_in_reserve.append(unit_level)

    def add_enemy_to_fight(self):
        self.enemies.append(UFO(copy.deepcopy(self.spawn_point), self.enemies_in_reserve.pop(0)))

    @staticmethod
    def trajectory(coord):
        coord[1] += 0  # x = x; y += 2
        return coord

    def start(self):
        self.timer.start(Board.SPEED, self)

    @staticmethod
    def in_range(target, tower) -> bool:  # return true if a particular unit in the tower's range
        dx = tower.position[0] - target.position[0]
        dy = tower.position[1] - target.position[1]
        distance = sqrt(dx ** 2 + dy ** 2)
        if distance <= tower.range:
            return True
        else:
            return False

    def shelling(self):
        for a in range(len(self.archers)):
            for e in range(len(self.enemies)):
                archer = self.archers[a]
                enemy = self.enemies[e]
                if self.in_range(enemy, archer):
                    self.enemies[e].take_damage(self.archers[a].make_damage())
                    if self.enemies[e].is_alive():
                        self.archersAttacks.append((enemy.position, archer.position))
                        break

        for w in range(len(self.wizards)):
            for e in range(len(self.enemies)):
                wizard = self.wizards[w]
                enemy = self.enemies[e]
                if self.in_range(enemy, wizard):
                    self.wizardsAttacks.append((enemy.position, wizard.position))
                    self.enemies[e].take_damage(self.wizards[w].make_damage())

    def timerEvent(self, a0: QtCore.QTimerEvent) -> None:
        if a0.timerId() == self.timer.timerId():
            for i in range(len(self.enemies)):
                self.enemies[i].move(self.trajectory(self.enemies[i].position))

            if self.fire_delay % 5 == 0:
                self.shelling()

            for enemy in self.enemies:
                if not(enemy.is_alive()):
                    self.enemies.remove(enemy)

            if self.fire_delay % 6 == 0:
                self.archersAttacks.clear()
                self.wizardsAttacks.clear()

            if self.wave_delay % 100 == 0:
                self.enemy_wave(self.wave_level)
                self.wave_level += 1

            if len(self.enemies_in_reserve) != 0 and self.spawn_delay % 2 == 0:
                self.add_enemy_to_fight()

            self.fire_delay += 1
            self.wave_delay += 1
            self.spawn_delay += 1
            self.update()

    def tile_width(self):
        return self.frameGeometry().width() / self.WIDTHINBLOCKS

    def tile_height(self):
        return self.frameGeometry().height() / self.HEIGHTINBLOCKS

    def board_generation(self):
        road_traj = [[i, i - 6] for i in range(6, 16)]
        for i in range(0, 3 * self.HEIGHTINBLOCKS + 3, 1):
            for j in range(0, self.WIDTHINBLOCKS + 1, 1):
                if i + j % 2 == 7 and j == 3:
                    self.land_tiles.append(Landscape(np.array([i, j]), self.biome, tower_place=True))
                elif [i + j % 2, j] in road_traj:
                    self.land_tiles.append(Road(np.array([i, j]), "Spring biome", "right"))
                else:
                    self.land_tiles.append(Landscape(np.array([i, j]), self.biome, tower_place=False))

    def y_coord(self, y_line):
        height = self.tile_height()
        if y_line == 0:
            return -height / 2 - self.tile_height() / 5.5 * y_line
        else:
            return height / 2 * (y_line - 1) - self.tile_height() / 5.5 * y_line

    def x_coord(self, x_line, y_line):
        width = self.tile_width()
        if y_line % 2 == 0:
            return -width / 2 + width * x_line
        else:
            return width * x_line

    def paintEvent(self, a0: QtGui.QPaintEvent) -> None:
        painter = QtGui.QPainter(self)

        rect = self.contentsRect()

        board_top = rect.bottom() - self.frameGeometry().height()

        for land in self.land_tiles:
            i = land.position[0]
            j = land.position[1]
            y = self.y_coord(i)
            x = self.x_coord(j, i)
            self.draw_rect(painter, rect.left() + x, board_top + y, land.skin)

        for archer in self.archers:
            coord = archer.position
            i = coord[0]
            j = coord[1]
            y = self.y_coord(i)
            x = self.x_coord(j, i)
            x_shift = self.tile_width() / 9
            y_shift = self.tile_height() / 5
            width_compression = 1.3
            height_compression = 1.3
            self.draw_rect(painter, rect.left() + x + x_shift, board_top + y - y_shift, archer.skin,
                           width=self.tile_width() / width_compression,
                           height=self.tile_height() / height_compression)

        for wizard in self.wizards:
            coord = wizard.position
            i = coord[0]
            j = coord[1]
            y = self.y_coord(i)
            x = self.x_coord(j, i)
            self.draw_rect(painter, rect.left() + x, board_top + y, wizard.skin)

        if self.fire_delay % 6 == 0:  # if it's fire iteration
            for enemy, archer in self.archersAttacks:
                print(archer, enemy)

                for e in self.enemies:
                    print(e.HP)

                x1 = self.x_coord(archer[1], archer[0]) + self.tile_width() / 2
                y1 = self.y_coord(archer[0]) + self.tile_height() / 4
                x2 = self.x_coord(enemy[1], enemy[0]) + self.tile_width() / 2
                y2 = self.y_coord(enemy[0]) + self.tile_height() / 4
                print(int(x1), int(y1), int(x2), int(y2))
                painter.drawLine(int(x1), int(y1), int(x2), int(y2))
                print("cool")
            for enemy, wizard in self.wizardsAttacks:
                x1 = self.x_coord(wizard[1], wizard[0])
                y1 = self.y_coord(wizard[0])
                x2 = self.x_coord(enemy[1], enemy[0])
                y2 = self.y_coord(enemy[0])
                painter.drawLine(int(x1), int(y1), int(x2), int(y2))

        for enemy in self.enemies:
            coord = enemy.position
            if coord[0] >= 20 or coord[1] >= 20:
                self.enemies.remove(enemy)
            else:
                i = coord[0]
                j = coord[1]
                y = self.y_coord(i)
                x = self.x_coord(j, i)
                self.draw_rect(painter, rect.left() + x + self.tile_width() / 4, board_top + y, enemy.skin,
                               width=self.tile_width()/2, height=self.tile_height()/2)

    def draw_rect(self, painter, x, y, image, width=None, height=None):
        if width is None:
            width = self.tile_width()
        if height is None:
            height = self.tile_height()
        rect = QtCore.QRect(int(x), int(y), int(width), int(height))
        painter.drawImage(rect, image)


class Unit:
    def __init__(self, coord, level, skins, direction):
        self.position = coord
        self.level = level
        self.direction = direction  # direct one for UFOs and reverse (from castle) for warriors
        self.HP = 100
        self.skin = skins[level]

        self.velocity = level  # 1, 2, 3 pixel/iteration
        self.force = 20 * level  # 20, 40, 60 damage (for units and castle)

    def move(self, coord):
        self.position = coord

    def take_damage(self, value):
        self.HP -= value
        if self.HP <= 0:
            self.HP = 0

    def is_alive(self) -> bool:
        if self.HP == 0:
            return False
        else:
            return True

    def make_damage(self) -> int:
        return self.force


class Warrior(Unit):
    def __init__(self, coord, level):
        skins = [QtGui.QImage("Sprites/Towers/Barrack/warrior_level_1.png"),
                 QtGui.QImage("Sprites/Towers/Barrack/warrior_level_2.png"),
                 QtGui.QImage("Sprites/Towers/Barrack/warrior_level_3.png")]
        super().__init__(coord, level, skins, "inverse")


class UFO(Unit):
    def __init__(self, coord, level):
        skins = [QtGui.QImage("Sprites/UFO/UFO(1).png"),
                 QtGui.QImage("Sprites/UFO/UFO(2).png"),
                 QtGui.QImage("Sprites/UFO/UFO(3).png"),
                 QtGui.QImage("Sprites/UFO/UFO(4).png"),
                 QtGui.QImage("Sprites/UFO/UFO(5).png"),
                 QtGui.QImage("Sprites/UFO/UFO(6).png"),
                 QtGui.QImage("Sprites/UFO/UFO(7).png")]
        super().__init__(coord, level, skins, "direct")


class Tower:
    def __init__(self, coord, level, skins):    # skins is array of QImage
        self.position = coord
        self.level = level
        self.skins = skins
        self.skin = skins[level]
        self.range = 10 * level  # 10, 20, 30 pixels
        self.force = 20 * level  # 20, 40, 60 damage
        self.upgrade_cost = level * 50  # 50, 100, 150 coins

    def change_picture(self):  # change picture in order to level
        self.skin = self.skins[self.level]

    def level_up(self):
        self.level += 1
        self.range = 10 * self.level  # 10, 20, 30 pixels
        self.force = 10 * self.level  # 20, 40, 60 damage
        self.upgrade_cost = self.level * 50  # 50, 100, 150 coins
        self.change_picture()

    def make_damage(self) -> int:
        return self.force

    def upgrade_cost(self) -> int:  # return upgrade cost
        return self.upgrade_cost


class Archer(Tower):
    def __init__(self, coord, level):
        skins = [QtGui.QImage("Sprites/Towers/Archer/archer_level_1.png"),
                 QtGui.QImage("Sprites/Towers/Archer/archer_level_2.png"),
                 QtGui.QImage("Sprites/Towers/Archer/archer_level_3.png")]
        super().__init__(coord, level, skins)


class Wizard(Tower):
    def __init__(self, coord, level):
        skins = [QtGui.QImage("Sprites/Towers/Barrack/wizard_level_1.png"),
                 QtGui.QImage("Sprites/Towers/Barrack/wizard_level_2.png"),
                 QtGui.QImage("Sprites/Towers/Barrack/wizard_level_3.png")]
        super().__init__(coord, level, skins)


class Tile:
    def __init__(self, coord, skin):
        self.position = coord
        self.skin = skin


class Road(Tile):
    def __init__(self, coord, biome, tile_type):    # np.array(x, y) coord, str biome : {"spring", "winter", "desert"},
                                                    # str tile_type : {"left", "right", "right_top_crossroad",
                                                    # "right_bottom_crossroad", "left_top_crossroad",
                                                    # "left_bottom_crossroad",  "bottom_twist", "top_twist",
                                                    # "right_twist", "left_twist"}
        biome = biome.title()
        skin = QtGui.QImage("Sprites/Road tiles/" + biome + "/" + tile_type + ".png")

        super().__init__(coord, skin)
        self.type = tile_type   # maybe will be needed


class Landscape(Tile):
    def __init__(self, coord, biome, tower_place=False):  # np.array(x, y) coord,
                                                          # str biome = {"spring", "winter", "desert"}, bool tower_place
        desert_biome = [QtGui.QImage("Sprites/Landscape tiles/sand.png"),
                        QtGui.QImage("Sprites/Landscape tiles/buildingPlaceSand.png")]
        spring_biome = [QtGui.QImage("Sprites/Landscape tiles/grass.png"),
                        QtGui.QImage("Sprites/Landscape tiles/buildingPlaceGrass.png")]
        winter_biome = [QtGui.QImage("Sprites/Landscape tiles/snow.png"),
                        QtGui.QImage("Sprites/Landscape tiles/buildingPlaceSnow.png")]

        skin = QtGui.QImage()

        if biome == "desert":
            if tower_place:
                skin = desert_biome[1]
            else:
                skin = desert_biome[0]
        elif biome == "spring":
            if tower_place:
                skin = spring_biome[1]
            else:
                skin = spring_biome[0]
        elif biome == "winter":
            if tower_place:
                skin = winter_biome[1]
            else:
                skin = winter_biome[0]

        super().__init__(coord, skin)
        self.tower_place = tower_place


class EnvironmentalTiles(Tile):
    def __init__(self, coord, biome, tile_type):    # np.array(x, y) coord, str biome = {"spring", "winter", "desert"},
                                                    # int tile_type
        skin = QtGui.QImage("Sprites/Environment tiles/crystal(1).png")
        super().__init__(coord, skin)


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()

        self.board = Board(self)
        self.setCentralWidget(self.board)
        self.setGeometry(100, 100, 1500, 1000)
        self.board.start()

        self.show()


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = MainWindow()
    MainWindow.show()
    sys.exit(app.exec_())
